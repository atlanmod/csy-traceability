/*
 * generated by Xtext 2.14.0
 */
package csy.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import csy.b.BPackage
import org.eclipse.xtext.EcoreUtil2
import csy.b.Abstraction
import csy.b.Implementation
import org.eclipse.xtext.scoping.Scopes
import csy.b.Operation
import org.eclipse.xtext.scoping.IScope
import csy.b.Variable
import csy.b.Machine
import csy.b.Definition
import csy.b.Var
import csy.b.LocalOperations

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class BScopeProvider extends AbstractBScopeProvider {
  
  override getScope(EObject context, EReference reference) {
    // Find operations in the refined machine and imported machines
    if (reference == BPackage.Literals.CALL__OP) {
      val abstr = EcoreUtil2.getContainerOfType(context, Abstraction)
      return getGlobalScopeFor(abstr, [a | getGlobalOperationsIn(a)])
    }
    
    // Find variables in own, refined, imported and seen machines
    if (reference == BPackage.Literals.REF__VAR
        || reference == BPackage.Literals.REF__TYPE
        || reference == BPackage.Literals.CASE_EXPR__TEST
        || reference == BPackage.Literals.RETURN_TUPLE__VARS
        || reference == BPackage.Literals.TYPE_CONSTRAINT__VAR) {
      val abstr = EcoreUtil2.getContainerOfType(context, Abstraction)
      val global = getGlobalScopeFor(abstr, [a | getGlobalVariablesIn(a)])          
          
      // Variables from definitions shadow the global variables
      val def = EcoreUtil2.getContainerOfType(context, Definition)
      if (def !== null) {
        return Scopes.scopeFor(def.args, global)
      }
      
      // Same thing for operations variables, but here we may have a 'VAR' block inside
      val op = EcoreUtil2.getContainerOfType(context, Operation)
      if (op !== null) {
        val op_scope = Scopes.scopeFor(op.args + op.outputs, global) 
        val var_block = EcoreUtil2.getContainerOfType(context, Var)
        if (var_block !== null) {
          return Scopes.scopeFor(var_block.vars, op_scope)
        }  
        return op_scope
      }
      
      return global
    }

    return super.getScope(context, reference)
  }
  
  def static <E extends EObject> IScope getGlobalScopeFor(Abstraction abstr,
                                                          (Abstraction) => Iterable<E> symbolsIn) {
    val own = symbolsIn.apply(abstr)
      
    // Machines have a 'SEES' clause
    if (abstr instanceof Machine) {
      val seen = if (abstr.sees !== null) abstr.sees.seens.map([symbolsIn.apply(it)]).flatten
                 else emptyList
                           
      return Scopes.scopeFor(own, Scopes.scopeFor(seen))                  
    }
      
    // Implementations have 'SEES' and 'IMPORTS'
    else if (abstr instanceof Implementation) {
      val refined = symbolsIn.apply(abstr.refine)
      val seen = if (abstr.sees !== null) abstr.sees.seens.map([symbolsIn.apply(it)]).flatten
                 else emptyList
      val imported = if (abstr.imports !== null) abstr.imports.imports.map([symbolsIn.apply(it)]).flatten
                     else emptyList
                       
      return Scopes.scopeFor(own,
        Scopes.scopeFor(refined, 
          Scopes.scopeFor(imported + seen)))                       
    }
    
    return IScope.NULLSCOPE
  }
  
  def static Iterable<Operation> getGlobalOperationsIn(Abstraction abstr) {
    EcoreUtil2.getAllContentsOfType(abstr, Operation)
      .filter[o | EcoreUtil2.getContainerOfType(o, LocalOperations) === null]
  }
  
  def static Iterable<Variable> getGlobalVariablesIn(Abstraction abstr) {
    EcoreUtil2.getAllContentsOfType(abstr, Variable)
      .filter[v | EcoreUtil2.getContainerOfType(v, Operation) === null]
      .filter[v | EcoreUtil2.getContainerOfType(v, Definition) === null]
      .filter[v | EcoreUtil2.getContainerOfType(v, Var) === null]      
  }
}
